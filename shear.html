<!doctype html public "-//w3c//dtd html 4.0 transitional//en">

<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<head>
<title>せん断変形を行う</title>
<link rel="stylesheet" href="style_ja.css">
</head>

<body>
<center><img src="logo_new.png" alt="Logo" width="600"><br><br><br><h2>せん断変形を行う</h2></center><br>

<h3>はじめに</h3>
この講座からは少しずつ材料力学的な内容になっていくが、それほど専門的な内容ではないので大学の教養物理学程度の知識があれば問題ないであろう。<br><br>

ある材料に関してその強度の情報が必要な場合、実験装置を用いて試料を強制的に変形しその応答を調べる方法がとられることが多い。そのような変形をMDによって実現すればこれまで実験的に行ってきた研究をMDで代替できるようになる。この講座では、そのような解析に用いる変形の一つであるせん断変形をMDで行う方法を学ぶ。<br><br>

せん断変形とは材料のある2つの平行な面で、例えば上下の面で、異なった横方向の力を加える種類の変形である。例えば、下の図のように材料の下部を固定し、上部を強制的に横方向に移動させる変形がせん断変形に属する。以下で、鉄の結晶をせん断変形するMDを紹介していく。<br><br>

		<br><br>
		<center><figure><img src="shear.jpg" width="500"><br><br><figcaption>Fig. 1: せん断変形MDを行う方法</figcaption></figure></center>
		<br><br>

<h3>せん断変形MDの実行</h3>
このMDを行うための大まかな手続きの流れを述べると、まず鉄の結晶を絶対0度で構造緩和させ、そしてある有限温度にてアニールする。このコースを最初から順番に学んできた人は、これらを行う方法はすでに学んだはずだ。その後、上図のように試料の下部を固定し、図の黒い矢印で示されたように上部を一定の速度で移動させることによってせん断変形を実現することができる。このMDを実行するためのスクリプトが<em>script</em>ディレクトリの中の<em>bccFe_shear.lcm</em>である。以下のコマンドラインを標準入力に入れることによりこのMDが実行される。

<pre>
$work> lmp_serial -v x_lattice 25 -v y_lattice 25 -v z_lattice 25 -v max_step 5000
-in script/bccFe_shear.lcm
</pre>

上のコマンドラインの<code>-v</code>はすでに紹介した<code>-in</code>と同じようにフラグの一種である。この<code>-v</code>フラグを使うことによって実行前にLAMMPSで使われる変数を定義することができる。この方法は１つのスクリプトで異なったケースを計算できる便利な方法なのでぜひ覚えておいて欲しい。以下で改めて説明するが、このケースではボックスのサイズが25<em>a</em>（<em>a</em>は格子定数）、およびせん断変形の持続時間長さ(5000 fs)が定義されている。<br><br>

LAMMPSでの計算が成功すると、<em>work</em>ディレクトリに<em>bccFe_shear_*.out</em>という形式のファイルが多数できる。ただし、<em>"*"</em>の部分は時刻に関する情報（すなわち計算ステップ数）が入る。これのどれかをOVITOで読み込めば、この形式のファイルは全て読み込まれる。前回と同様に動画を実行すればせん断変形の様子を観察することができる。下に<em>xz</em>面で見た動画を置いておくので自分のと見比べて欲しい。<br><br>

<center>
<figure>
<video width="500" controls>
  <source src="bccFe_shear.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
<br><br>
<figcaption>Video 1: せん断変形MDから得られた動画 </figcaption>
<figure>

</center>


<h3>スクリプトの説明</h3>
<h4>基本結晶を作る</h4>
	
さて、いつものようにスクリプトを見ていこう。まずは最初のブロックを表示する。
<pre>
# variable x_lattice equal 25
# variable y_lattice equal 25
# variable z_lattice equal 25
# variable max_step equal 5000
</pre>
		
最初の4行はコメント文でLAMMPSの実行には何も影響を与えない。ここでコメントアウトされた<code>variable</code>コマンドの変数は上記のコマンドラインにおける<code>-v</code>フラグで定義され、値が与えられる。そのことを忘れないようにここに記述した。すなわち上の実行コマンドのように<code>-v</code>フラグ使うということは、上記４つのコメント文をアンコメントしてこれら4変数を定義したことと等価になる。<br><br>
次のブロックを表示する。
<pre>
units metal
boundary p p p
atom_style atomic
lattice bcc 2.83 orient x 1 0 0 orient y 0 1 0 orient z 0 0 1
region sim_box block 0 ${x_lattice} 0 ${y_lattice} 0 ${z_lattice} units lattice
create_box 1 sim_box
create_atoms 1 box
</pre>

この部分はすでに<a href="relax.html">構造緩和を行う</a>で説明したスクリプトの最初の部分とほぼ同じなので、改めて説明の必要はないはずだ。違うところは<code>region</code>コマンドにおいて変数が使われていることだけである。LAMMPSのスクリプトでは、<em>${a}</em>という記述は変数<em>a</em>を参照する時に使われる。よって、この<code>region</code>コマンドは、<em>x_lattice</em>などの変数が代入されて実行されたことになる。（厳密には<em>x_lattice</em>で定義された文字列が代入されただけだが、結果的に数値が代入されたことと等価なので、今そのことを気にする必要はない。）このように<code>-v</code>フラグを使えば、LAMMPSを実行させるごとにボックスの大きさを変えたりでき、1つのスクリプトを柔軟に運用できる。<br><br>

<h4>上下の面を“削る”</h4>

<pre>
variable boundary_width equal 3
variable vacuum_high equal ${z_lattice}-${boundary_width}
region lower_vacuum block INF INF INF INF INF ${boundary_width} units lattice
region upper_vacuum block INF INF INF INF ${vacuum_high} INF units lattice
delete_atoms region lower_vacuum
delete_atoms region upper_vacuum
</pre>

さてこの部分はちょっと複雑なので以下をじっくり読んで欲しい。1つ前のブロックにおける<code>boundary</code>コマンドでは、3方向で周期的境界条件が指定されている。これは上の図の上下の面が連続していることを意味している。よってこのままで上の図のようなせん断変形を行うと上の面の動きに下の面が引きずられてしまう。これを避けるためには、上下の面を乖離させる必要がある。そのため、上下それぞれの面を少しずつ削ることにする。それを行なっているのがこのブロックである。<br><br>

最初の<code>variable</code>コマンドではその削り幅<em>boundary_width</em>を<em>"3"</em>と定義した。後のコマンドでわかるが数値の単位は格子定数である。よって材料サンプルの上下の面は格子定数の6倍の距離だけ離されることになりお互いの影響はなくなる。次の<code>variable</code>コマンドでは削られたあとの新たな上面の位置が定義されている。<br><br>

次の2つの<code>region</code>コマンドは、削られる上下の領域、<em>lower_vacuum</em>と<em>upper_vacuum</em>を定義している。すでに学んだが<code>block</code>は領域の種類を表すキーワードでここでは直方体の空間で、続く6つの値によって具体的な領域が定義される。<em>INF</em>もすでに出てきたが限界の値をとることを意味している。それに続く、<code>units lattice</code>では<code>region</code>コマンドで使われる数値の単位を格子定数に指定している。これは上で意図した通りである。<br><br>
		
最後の2つの<code>delete_atoms region</code>コマンドは指定された領域の中の全原子を削除するコマンドで、これで上下の面を少しずつ削ることができる。<br><br>

次に行く。

<h4>強制的に動かす部分を定義</h4>

<pre>
variable	lower_board equal ${boundary_width}+${boundary_width}
variable	upper_board equal ${vacuum_high}-${boundary_width}
region		lower block INF INF INF INF INF ${lower_board} units lattice
region		upper block INF INF INF INF ${lower_board} INF units lattice
group		lower region lower
group		upper region upper
group		boundary union lower upper
group		mobile subtract all boundary
</pre>

このコマンドブロックでは<b>Fig. 1</b>のグレーの部分、すなわち固定する底板と移動させる天板を定義する。<br><br>

最初の2つの<code>variable</code>コマンドは底板の一番上の位置と天板の一番下の位置を定義している。<br><br>

次に底板と天板の領域を<code>region</code>コマンドで定義する。この領域には上で作った真空の部分も含まれるが、もうそこには原子はないのでこの後の処理において気にする必要なない。<br><br>

次の2つの<code>group ... region</code>コマンドは<code>region</code>の後に記述された領域（ここでは<em>lower</em>と<em>upper</em>）内にある全ての原子をグループ化するコマンドである。<br><br>

次の<code>group ... union</code>コマンドは<code>union</code>の後に記述された複数のクループを足し合わせて新たなグループを作るコマンドである。ここで底板と天板のグループを足し合わせて新たに<em>boundary</em>というグループを作った。<br><br>

次の<code>group ... subtract</code>コマンドは<code>group ... union</code>の逆でグループの引き算である。ここでは全体ボックス内の全ての原子<em>all</em>グループから<em>boundary</em>グループに属する原子を削除し、残った原子グループを新たに<em>mobile</em>と定義する。<br><br>

なお、<code>region</code>と<code>group</code>は混同しやすいが、<code>region</code>は空間、<code>group</code>は原子の集まりと覚えておこう。<br><br>		

次に行く。

<h4><a name="neighbor">原子間相互作用の定義</a></h4>
<pre>
pair_style eam/fs
pair_coeff * * ./potentials/Fe_mm.eam.fs Fe
neigh_modify every 1 delay 0 check yes
</pre>

最初の2行は鉄の原子間ポテンシャルの定義であり、<a href="relax.html">構造緩和を行う</a>のところで説明したので繰り返さない。<br><br>
		
次は、<code>neigh_modify</code>コマンドであるが、１つの講座で学習することが多くならないようにこれまでこのコマンドの説明を避けてきた。この講座ではきちんと説明しよう。<br><br>

実はこのコマンドの前に隠れたコマンドがあり、それを最初に説明する。それはNeighborリストの定義である。LAMMPSにおいて使われる原子間ポテンシャルではある距離より遠い原子ペアでは原子間力を無視するとするcutoff距離が定義されている。これにより不要な計算を避けることができる。逆に言えば、cutoff距離より近い原子ペアでは原子間ポテンシャルが計算される。Neighborリストとはその計算を行うペアのリストである。<br><br>

ここまでは建前で、しかし現実的には、原子が移動するので、少し余裕を持たせてcutoff距離より少し離れている原子ペアも原子間ポテンシャルを計算させなければならない。この余裕のことをskinと呼ぶ。

隠れたコマンドはスクリプト全体の最初に<code>units metal</code>が選ばれた場合のディフォルトは<code>neighbor 2.0 bin</code>となる。このコマンドの意味するところは、厚さ2.0 Angstromのskinを用いる。	また、ここで記述された<em>bin</em>はネイバーリストを作るアルゴリズの種類であり詳しいことは説明しないが、興味のある受講者は<a href="https://www.lammps.org/tutorials/sor13/SoR_01-Overview_of_MD.pdf">Steve Plimpton氏による発表スライド</a>のp13を参照して欲しい。<br><br>

よって実際にはこのコマンドがすでに実行されている。ちなみに、skinが増えれば使用するメモリが増えるので計算中メモリがいっぱいになってしまう場合は、許される範囲でskinを薄くすることを考えてもいい。
<br><br>

本題の<code>neighbor_modify</code>コマンドの説明にもどろう。ここでは、<code>every "n" delay "m"</code>は新しいNeighborリストがビルドされてから<em>m</em>ステップ数の後、<em>n</em>ステップ数の度にリストが更新されることを意味している。ただし、<code>check yes</code>はある条件を満したときのみリストを更新することを指定している。この条件とは原子の移動距離がskinに達した場合である。ディフォルトは<code>every 1 delay 0 check yes</code>である。よって元々このコマンドラインは不要なのだが、ここに書いておいたのはこれらのパラメータを変えることによって計算時間を短縮できる可能性があるからだ。例えば、原子が激しく動いていない場合にはリスト更新を間引きしてもよいし、逆に原子が激しく動く場合はいちいちチェックする計算時間がもったいないので<code>check no</code>がいいかもしれない。<br><br>		

以上少し細かい設定の話で辟易したかもしれない。初心者は問題がなければディフォルトの設定にしておくのが良い。次に行く。
		
<h4>構造緩和を行う</h4>
<pre>
fix 1 all box/relax iso 0.0 vmax 0.001
thermo		200
thermo_style custom step pe lx ly lz press
min_style cg
minimize 1.e-25 1.0e-12 10000 50000
unfix 1
</pre>
<code>fix ... box/relax</code>コマンドは体積緩和を行うためのコマンドで、すでに習った。<br><br>

次の<code>thermo</code>コマンドは系の熱力学的変数を計算するインターバルを指定するコマンドであり、200計算ステップごとにそれらの変数が計算されその結果が標準出力に出力されることになる。<br><br>

次の<code>thermo_style custom</code>コマンドはその標準出力への出力フォーマットを定義する。この例では<em>step</em>（シミュレーションステップ）、<em>pe</em>（全ポテンシャルエネルギー）、<em>lx ly lz</em>（ボックスの3方向のサイズ）、<em>press</em>（圧力）が表示されるようになる。<br><br>

次の<code>min_style</code>コマンドと<code>minimize</code>コマンドは<a href="relax.html">構造緩和を行う</a>のところで出てきたので説明を繰り返さない。<br><br>

次の<code>unfix</code>コマンドもすでに学んだ。これは<code>fix</code>コマンドが使われてその役目を終えた時、それを無効化する手続きである。ここでは構造緩和の計算が終了したのでこのブロック先頭の<code>fix ... box/rescale</code>コマンドを無効化している。<br><br>

次のブロックに行く。
		
<h4>アニーリングを行う</h4>
<pre>
variable set_temp equal 10.
velocity 	mobile create ${set_temp} 1582775
fix		1 all nve
fix		2 boundary setforce 0.0 0.0 0.0
fix		3 mobile temp/rescale 10 ${set_temp} ${set_temp} 0.1 1.0
reset_timestep 	0
run 		1000
</pre>

このスクリプト部分では底板と天板に挟まれた<em>mobile</em>グループに属する原子群を設定温度でアニールする。<br><br>

次の<code>variable</code>コマンドでは<em>set_temp</em>という変数を定義し"10"を代入している。<br><br>

次の<code>velocity ... create</code>コマンドは<a href="anneal.html">アニーリングを行う</a>ですでに述べたが温度を設定するためのコマンドである。ここでは<em>mobile</em>グループの原子群に<em>set_temp</em>で定義された温度（K）を入れている。<em>mobile</em>グループは底板と天板に挟まれた場所にある原子群である。<br><br>

次の<code>fix ... nve</code>コマンドは系全体（すなわち<em>all</em>グループ）を原子数一定、体積一定、エネルギー一定で（すなわちミクノカノニカルアンサンブルで）時間積分を行うことを指定している。お分かりと思うが、ここでは計算法を指定しただけで、実際の計算はまだ始まらない。<br><br>

次の<code>fix ... setforce</code>コマンドは原子間力を強制的に与えるためのコマンドで底板と天板を合わせた<em>boundary</em>グループでは原子間力が消滅する。すでに述べたが、これらの部分の原子の運動は原子間ポテンシャルによって決まるのではなく強制的に固定したり動かしたりする部分なのでこのような設定にしておく。材料変形のMDでは、このように強制的に原子群を固定したり動かしたりする場面が出てくるが、その時この<code>fix ... setforce</code>コマンドが大いに役に立つだろう。ここで<code>fix</code>コマンドの識別子が<em>"2"</em>になっていることに注目しよう。<code>fix</code>コマンドは複数実行することができ、識別子によって区別される。無論、同じ識別子を持つ2つ以上の<code>fix</code>コマンドを同時に実行することはできない。<br><br>

次の<code>fix ... temp/rescale</code>コマンドは<a href="anneal.html">アニーリングを行う</a>で既出であるので詳しい説明はしないが、温度調整が<em>mobile</em>グループだけになっている。これは原子間ポテンシャルによって有限温度で時間発展するのが<em>mobile</em>グループだけだからである。<br><br>

次の<code>reset_timestep</code>コマンドもすでに説明したが、シミュレーションの時間ステップを初期化している。実は何もしなくても最初は時刻<em>"0"</em>に初期化されるので、このコマンドは必要ないのだが、スクリプトの意図を明確にするために書いておいても良い。<br><br>

さてここまで準備ができて、やっとアニールを<code>run</code>コマンドで実行する。ここでは計算の負荷を減らすために1000ステップ（1 ps）の長さにしてあるが、本来ならこの100倍の100 ps程度にした方が良いだろう。これで<em>mobile</em>グループの中の原子がアニーリングされることになる。ただ、<code>fix ... setforce</code>コマンドによって<b>Fig. 1</b>の上下のグループは動かないので、<em>boundary</em>グループ原子が<em>mobile</em>グループの中に入り込んだり、その逆の現象も起きない。<br><br>

次に行こう。

<h4>せん断変形を行う</h4>
<pre>
velocity	upper set 0.1 0. 0.
reset_timestep 	0
dump 		1 all custom 200 bccFe_shear_*.out id type xs ys zs
run		${max_step}
</pre>

これがスクリプトの最後の部分である。まず<code>velocity ... set</code>コマンドだが、前出の<code>velocity ... create</code>ととは異なって指定されたグループに一様な速度を与えるコマンドである。最初の引数の<em>upper</em>は速度が与えられるグループで、<b>Fig. 1</b>の天板に属する原子群である。<code>set</code>に続く3つの数字はそれぞれ<em>(x,y,z)</em>方向の速度である。速度の単位だが、スクリプトの最初で<code>units metal</code>が宣言されたいるのでAngstrom/psになる。<br><br>
		
次の<code>reset_timestep</code>コマンドはすでに説明した。この場合は時刻はすでに1000ステップ（1 ps）まで進んでいるので<em>"0"</em>にしたい場合は省略することはできない。<br><br>

次の<code>dump</code>コマンドもこれまでの説明からほぼ理解できるだろう。これまでと違う点はファイル名に<em>"_*"</em>という部分を加えたことである。これまでは<code>dump</code>コマンドで出力されたファイルは1つのファイルであったが、この方法だと1つのファイルのサイズが大きくなりすぎる場合がある。今回のようにすると、上で見たように<em>bccFe_shear_0.out</em>から200ステップ刻みで複数のファイルができることになり、1個のファイルが大きくなるのを防ぐことができる。<br><br>
		
そして最後の<code>run</code>コマンドで上の標準入力へのコマンドラインで指定された時間長さだけシミュレーションが行われる。これでスクリプトの説明は終わりだ。このスクリプトに限らないが、おおよその内容がわかったらパラメータを変化させて様々なケースを行なうと理解が進むだろう。<br><br>

構造緩和とアニーリングを行った後、興味ある現象のMDを行うという流れはよく使うので、今回のスクリプトは様々なスクリプトの雛形となるだろう。<br><br><br><br>
		
<center>
<a href="index.html">目次へ</a>     前は<a href="anneal.html">アニーリングを行う</a>     次は<a href="tensile.html">引っ張り変形を行う</a></center>
<br><br>
</body>
</html>
