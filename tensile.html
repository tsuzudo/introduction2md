<!doctype html public "-//w3c//dtd html 4.0 transitional//en">

<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<head>
<title>引っ張り変形を行う</title>
<link rel="stylesheet" href="style_ja.css">
</head>

<body>
<center><img src="logo_new.png" alt="Logo" width="600"><br><br><br><h2>引っ張り変形を行う</h2></center><br>
<h3>はじめに</h3>
さて、前回の講座では材料のせん断変形をモデリングするためのMDについて学んだ。材料科学においてせん断変形と同等に重要な変形が引っ張り変形である。これは、材料を上下方向に伸ばすように変形することを意味する。<br><br>

実験的な研究において、引っ張り変形は材料の延性（伸び易さ）や破壊強度を解析するために頻繁に使われる方法である。破壊は実生活においてあまり望ましい現象ではないが、落とした皿が割れることなど身近な現象でもある。より深刻なのは、地震、台風、津波などの影響で橋や道路など社会インフラにおいて起きる場合である。<br><br>

このように、破壊は巨視的なすなわち肉眼で見える現象として観察されるが、その物理的本質は原子間結合の解離であり、その現象の本質を原子レベルで実験的に直接観察することは今の科学ではできない。そのため、いままで壊れなかったものがどうしてその時になって初めて壊れたのか、またどうして他の場所でなくその場所で破壊が起きたのかなど、破壊について理解できない単純な疑問はいくつもある。よって破壊のメカニズム研究は、原子レベルの挙動をモデリングするMDの応用が強く望まれる分野の一つである。<br><br>

すなわち、ここで学ぶMDは実学的に重要なテクニックの基礎となっている。<br><br>


<h3>引っ張り変形MDの実行</h3>
引っ張り変形のMDを行う場合、破壊の起点となる切り欠きなどをあらかじめ入れてMDを行うことが多いが、ここでは前回と同じようにこの変形をMDで行う方法のみに注目したいので、鉄の完全結晶を変形する例を示す。<br><br>
		
このMDのスクリプトは<em>script</em>ディレクトリの中の<em>bccFe_tensile.lcm</em>である。実行は以下のコマンドで行う。
<pre>
$work> lmp_serial -in script/bccFe_tensile.lcm
</pre>

これにより<em>bccFe_tensile_*.out</em>という形式のファイルが多数出力される。その一つ、例えば最初のファイル<em>bccFe_tensile_0.out</em>をOVITOに読み込ませると自動的に同じ形式のその他のファイルも読み込まれる。OVITO画面下の<em>Play</em>ボタンでアニメーションを実行して、下の動画のように上下に伸びている様子が確認できれば成功である。<br><br>

<center>
<figure>
<video width="500" controls>
  <source src="bccFe_tensile.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>
<br><br>
<figcaption>Video 1: 引っ張り変形MDのアニメーション</figcaption>
</figure>
</center>
<br><br>

<h3>スクリプトの説明</h3>
<h4>基本結晶を作る</h4>
以下で、このMDで使われたスクリプトをステップバイステップで見ていくことにする。
<pre>
units metal
boundary p p p
atom_style atomic
variable 	lc equal 2.83
lattice bcc ${lc} orient x 1 0 0 orient y 0 1 0 orient z 0 0 1
variable 	x_box equal 30*${lc}
variable 	y_box equal 30*${lc}
variable 	z_box equal 50*${lc}
region box block 0 ${x_box} 0 ${y_box} 0 ${z_box} units box
create_box 1 box
create_atoms 1 box
</pre>
<code>units</code>コマンド、<code>boundary</code>コマンド、<code>atom_style</code>コマンドの説明はもう繰り返さないので、わからない受講者は<a href="relax.html">構造緩和を行う</a>の講座へ戻って確認してほしい。<br><br>

次の<code>variable</code>コマンドでは<em>lc</em>という変数を定義している。後からわかるがこれはここで使われる鉄の原子間ポテンシャルの格子定数である。<br><br>

次の<code>lattice</code>コマンドは過去の講座で出てきた。サンプルの初期値を作るときに使う格子系を定義するためのコマンドである。<br><br>

次の３つの<code>variable</code>コマンドは<em>x_box</em>、<em>y_box</em>、<em>z_box</em>の3つの変数をそれぞれ格子定数の30倍として定義する。<br><br>

次の<code>region</code>コマンドも既出であるが、ここでは<em>box</em>という名前の直方体領域を定義する。ここで、最後の引数が<code>units box</code>になっていることに注目して欲しい。これまでは<code>units box</code>の代わりに<code>units lattice</code>が用いられてきており、その場合は長さの単位が格子定数がなっていた。<code>units box</code>が指定されると、このコマンドで使用された長さの単位がAngstromになる。要するに上の3つの<code>variable</code>コマンドは<code>units box</code>を使うための準備だったわけである。<br><br>

ボックスを定義するときに長さの単位を前回までの講座のように<em>lattice</em>（格子定数）としても今回のように<em>box</em>（すなわちAngstrom）しても本質的に違いはない。自分の経験では<em>box</em>にする方がプログラミングの自由度が増すので、スクリプトが複雑になるにつれ<em>box</em>の方が楽になる傾向がある。<br><br>

その後の2つのコマンドは既出であるが、<code>create_box</code>は上で作られた<em>box</em>と呼ばれる領域から計算に使用するボックスを作っており、最後の<code>create_atoms</code>はそのボックスの中に、上の<code>lattice</code>コマンドで指定した結晶系を作るようにタイプ<em>1</em>の原子を入れるためのコマンドである。<br><br>


<h4>原子間相互作用の定義</h4>		
次のブロックを示す。
<pre>
pair_style eam/fs
pair_coeff * * potentials/Fe_mm.eam.fs Fe
neigh_modify every 1 delay 0 check yes
</pre>	

ここでは原子間ポテンシャルの指定および、それを使って原子間力を計算が行われる原子ペアのリスト（Neighborリスト）の更新に関するオプションを指定している。Neighborリストについては<a href="shear.html#neighbor">前回の講義</a>で詳しく説明しているの。このブロックの詳しい説明は不要と思う。<br><br>

次に行こう。

<h4>構造緩和を行う</h4>
<pre>
variable 	dump_step equal 200
thermo ${dump_step}
thermo_style custom step pe lx ly lz press
min_style cg
min_modify dmax 0.05
minimize 1.0e-25. 1.0e-12 10000 50000 
</pre>	
		
このブロックでは構造緩和を行っている。まず<code>variable</code>コマンドで<em>dump_step</em>という変数を定義した。<code>thermo</code>コマンドではシミュレーションの途中に熱力学変数を計算し出力する頻度を指定する。その次の<code>thermo_style</code>コマンドではどういう変数を標準出力に出力させるかを指定する。ここでは時間ステップ、全ポテンシャルエネルギー、ブロックの<em>x、y、z</em>方向の長さ、圧力である。<br><br>
		
次の<code>min_style</code>コマンドは構造緩和のアルゴリズムの指定、ここでは共役勾配法が使われている。<br><br>

<code>min_modify</code>コマンドでは構造緩和の速さの上限を指定する。ここでは1イタレーションでそれぞれの原子位置が<em>0.05</em> Angstrom以上は変化しないとする。構造緩和がうまくいかない場合はより小さい値にし、収束が遅すぎる場合にはより大きい値にすべきである。ディフォルト値が<em>0.1</em>なのでそれ以外の値を指定したい時だけこのコマンドを使う。普段は何もしなくて良いが、変える場合はこのコマンドを使う。<br><br>

最後の<code>minimize</code>コマンドで構造緩和が実行される。4つの引数については<a href="relax.html">構造緩和を行う</a>の講座で説明したのでここでは繰り返さない。<br><br>

これで引っ張り変形をするための初期値ができた。以下では変形を実行していく。

<h4>引っ張り変形に必要な変数を定義する</h4>
<pre>
variable 	lx_current equal lx
variable 	ly_current equal ly
variable 	lz_current equal lz
variable 	lx0 equal ${lx_current}
variable 	ly0 equal ${ly_current}
variable 	lz0 equal ${lz_current}
variable 	dstrain equal 0.001
variable	poisson_ratio equal 0.27
variable 	lz_delta equal ${dstrain}*${lz0}/2
variable 	lx_delta equal ${lz_delta}*${poisson_ratio}
variable 	ly_delta equal ${lz_delta}*${poisson_ratio}
</pre>
<em>lx_current</em>、 <em>ly_current</em>、および<em>lz_current</em>はボックスすなわち材料の大きさである。また、<em>lx0</em>、 <em>ly0</em>、および<em>lz0</em>も同じものとして定義されている。後でわかるが、<em>lx_current</em>らは引っ張り変形を行っている時の現在値で、<em>lx0</em>らはその初期値、すなわち構造緩和直後の大きさとして使用する。<br><br>
		
さて後で詳細を説明するが、この講座のMDでは前講座の<a href="shear.html">せん断変形を行う</a>のように系をアニーリングした後にある部分に強制的な速度を与えて系を変形するような方法を使わない。ここでは絶対零度のまま材料を小さな刻みで無限の速さで変形し変形後に構造緩和をさせる過程を繰り返すような方法を採用する。<br><br>

次の行で定義された<em>dstrain</em>は1刻みあたり変形の割合であり、ここでは<em>z</em>方向の初期長さ<em>lz0</em>の0.1%ずつ引っ張り変形していくことになる。<br><br>
		
次の<em>poisson_ratio</em>は材料のポアソン比である。鉄結晶が<em>z</em>方向に伸ばされれば横方向に縮むことになるがその割合を示すのがポアソン比であり文献値を代入しておく。<br><br>
		
後で出てくるが1刻みの微小な変形はボックスの3方向の境界を微小に動かすことによって実現する。<em>lz_delta</em>、<em>lx_delta</em>、<em>ly_delta</em>は1刻みあたりに動く幅であり、<em>z</em>方向の定義で2で割られているのは上下の境界を両方とも動かすためで、これにより1刻みあたり上下の長さは<em>lz_delta*2</em>だけ伸びることになる。また<em>lx_delta</em>、<em>ly_delta</em>の定義にはポアソン比が使われる。<br><br>
		
<h4>引っ張り変形を実行する</h4>
それではスクリプトの最後の部分を示そう。
		
<pre>
reset_timestep 0
dump 1 all custom ${dump_step} bccFe_tensile_*.out id type xs ys zs
variable 	final_strain equal 0.04
variable 	nloop equal ${final_strain}/${dstrain}
variable loop loop ${nloop}
label loop_start
	print " "
	print " "
	print "%%%%% LOOP INCREMENT ${loop} %%%%"
	change_box all x delta ${lx_delta} -${lx_delta} y delta ${ly_delta} -${ly_delta} &
	z delta -${lz_delta} ${lz_delta} remap units box
	minimize 1.0e-25 1.0e-25 1000 10000
	run 0
	next loop
jump SELF loop_start
</pre>
最初の<code>reset_timestep</code>はこれまで何度か出てきたが、時刻の初期化である。<br><br>

<code>dump ... custom</code>コマンドもここまで何度か出てきたので詳細は説明しないが、各原子の途中経過の状態をファイルに出力するためのコマンドである。<br><br>

次の変数<em>final_strain</em>はこの引っ張りシミュレーションによる最終的な伸びを定義する。ここでは、最終的に<em>4</em>%まで伸ばすことにする。<br><br>

次の変数<em>nloop</em>は最終的な伸びを上で出てきた微小な引っ張りによる伸びで割っているので微小な引っ張りを行う回数になる。<br><br>

次の<code>variable ... loop</code>コマンドは初出である。<code>variable ??? loop $$$</code>という構文で繰り返し計算でインクリメントされる変数を定義する。ここで<em>???</em>は変数名でその初期値は<em>1</em>にセットされる。<em>$$$</em>はその繰り返し数または繰り返し過程におけるloop変数の最後の値である。これで以下の繰り返し計算をする準備が整った。<br><br>

次の<code>label</code>コマンドは一番下の<code>jump</code>コマンドの行き先を指定する。この後の説明でこの<code>label</code>コマンドが繰り返し計算においてどのように使われるかが明らかになるので、このまま進もう。<br><br>

この後インデントされている部分が繰り返される部分である。まず最初の3つの<code>print</code>コマンドは標準出力へこの繰り返し計算の途中経過を表示するためのものである。<br><br>

次の2行は<code>&</code>で繋がっていて1つの文である。この<code>change_box</code>コマンドはボックスの境界を強制的に移動させるコマンドであり、<em>x delta</em>、<em>y delta</em>、<em>z delta</em>のキーワードが記述された場合、それぞれボックスの下境界と上境界の移動差分が指定される。ここでは<em>x</em>と<em>y</em>方向では下境界が増加し上境界が減少しているので圧縮され、<em>z</em>方向では逆に伸ばされることがわかる。<code>remap</code>はこのコマンドのキーワードで変形の度合いに比例して原子位置を変えることを要求し、その後の<code>units box</code>はこのコマンドに使われた長さの単位がAngstromであることを示している。これが上で何度か述べた微小な引っ張り変形の実体である。<br><br>

<code>minimize</code>は上の微小な強制的変形後の構造緩和させるコマンドである。<br><br>

次の<code>run 0</code>は少し使い方がトリッキーだ。これまでの<code>run</code>コマンドは与えられたステップ数だけ動的な計算を行うために使われてきたが、ここでは引数が<em>"0"</em>となっていて奇妙だ。これは単に系の熱力学変数を計算させるためだけにこのコマンドが使われている。<br><br>

<code>next loop</code>では<em>loop</em>という変数を次の値にする。ここではこれまでの値に<em>1</em>が足されることになる。<br><br>

最後の<code>jump</code>コマンドはスクリプトのある位置にジャンプさせるためのコマンドであり、最初の引数に<em>SELF</em>が記述された場合にはこのスクリプトの第2引数で指定された<code>label</code>にジャンプする。最初の引数はスクリプトのファイル名でもよく、他のスクリプトが記述された場合には、そのスクリプトに移動する。ここではこの繰り返し計算ループの最初に戻ることになる。ただし、前の<code>>next</code>コマンドで<em>loop</em>が繰り返しの範囲（ここでは<em>nloop</em>）を超えていたらこの文は無視されて、繰り返し計算が終了することになる。このケースではスクリプト全体の最後なのでLAMMPSが終了することになる。<br><br>
		
<h3>ディスカッション</h3>

少し進んだ内容で恐縮だが、この講座を終える前に受講者に知っておいてもらいたいことがある。１つ前の講座では<a href="shear.html">せん断変形を行う</a>MDを紹介した。そこでは材料のある部分に強制的に速度を与えて変形する方法を用いた。その方法をこの講座で紹介した引っ張り変形に適用することも可能だ。<br><br>

ただし、速度を与える方法だと、どうしても実験で行う変形よりも変形速度が非現実的に速くなるという問題がある。実験における変形時間は通常秒単位で電子顕微鏡などで観察できる。しかし、MDで追跡できる時間は長くてもnano秒単位である。一つの解決法は今回のように0 Kで微小に変形して緩和させる手続きを繰り返すことである。この場合は微小な変形の後、毎回構造緩和させているので、変形速度が速くて現実的でないという批判からは逃れられる。<br><br>

ただし、ここで紹介した方法は有限温度では使えないテクニックなので、格子振動が変形に影響を及ぼす場合などには応用できない。実際、材料は温度が高くなるにつれ塑性変形が起き易くなり、破壊が抑制される。よって有限温度で非常にゆっくり変形するMDが理想的だが、最新のスーパーコンピュータでさえそれには限界がある。すなわち、どちらの方法を選んだとしても一長一短があるということだ。<br><br>

勘違いしないで欲しいが、有限温度の変形MDが全く現実を反映していないということではない。「MD結果は常に正しい」と盲目的に信じるのは危険であり、丁寧な考察が求められるということを忘れてはならない。<br><br><br><br>
<center>
<a href="index.html">目次へ</a>     前は<a href="shear.html">せん断変形を行う</a>     次は<a href="cascade.html">照射損傷をモデル化する</a></center>
<br><br>
</body>
</html>
